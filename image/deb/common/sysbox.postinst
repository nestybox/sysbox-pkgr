#!/bin/bash
#
# Copyright: (C) 2019-2020 Nestybox Inc.  All rights reserved.
#

set -e

# Source debconf library.
. /usr/share/debconf/confmodule

# Dockerd default configuration dir/file.
dockerCfgDir="/etc/docker"
dockerCfgFile="${dockerCfgDir}/daemon.json"

# sysbox-fs' default mountpoint path.
sysboxfs_mountpoint="/var/lib/sysboxfs"

# UID-shifting module
shiftfs_module="shiftfs"

# Kernel's pool-size of inotify resources.
inotify_pool_size=1048576

# Docker restart/sighup globals.
docker_restart_required=false
docker_sighup_required=false


# Kernel's keyring max keys limit. In debian-based distros (e.g.,
# Ubuntu) the kernel keyring max keys limit is set to 200 for non-root
# users.  This is too low for Sysbox. For example, for a sys container
# based K8s cluster, the number of keys required is:
#
#             keys = 35 + (k8s_workers * 23) + (2 * pods)
#
# That is, a 10-node cluster would need 282 keys.
#
# In a large bare-metal machine, we expect ~100 sys containers. That
# would consume ~11K keys.  To be conservative, we set maxkeys to
# 20K. Note that since each key consumes 20KB, the total mem
# consumption assuming all 20K keys are used is 400MB.
#
keyring_maxkeys=20000

# Creates sysbox-fs mountpoint.
create_sysboxfs_mountpoint() {

    if [[ -d ${sysboxfs_mountpoint} ]]; then
        return
    fi

    mkdir -p ${sysboxfs_mountpoint}
    if [[ ! -d ${sysboxfs_mountpoint} ]]; then
        exit 1
    fi
}

# Enables the utilization of unprivileged user-namespaces.
enable_unprivileged_userns() {

    val=$(sysctl kernel.unprivileged_userns_clone)
    if [[ "${val##* }" = 0 ]]; then
        sysctl -w kernel.unprivileged_userns_clone=1 >/dev/null 2>&1
    fi
}

# Ensure kernel's 'inotify' resources meet sysbox requirements -- default values
# in most distros are too low for decent-size scenarios.
define_inotify_resources() {

    val=$(sysctl fs.inotify.max_queued_events)
    if [[ "${val##* }" -lt ${inotify_pool_size} ]]; then
        sysctl -w fs.inotify.max_queued_events=${inotify_pool_size} >/dev/null 2>&1
    fi

    val=$(sysctl fs.inotify.max_user_watches)
    if [[ "${val##* }" -lt ${inotify_pool_size} ]]; then
        sysctl -w fs.inotify.max_user_watches=${inotify_pool_size} >/dev/null 2>&1
    fi

    val=$(sysctl fs.inotify.max_user_instances)
    if [[ "${val##* }" -lt ${inotify_pool_size} ]]; then
        sysctl -w fs.inotify.max_user_instances=${inotify_pool_size} >/dev/null 2>&1
    fi
}

# Ensure kernel's 'keyring' resources meet sysbox requirements --
# default values in most distros are too low for decent-size
# scenarios. See definition of keyring_maxkeys variable above for
# details.
define_keyring_resources() {

    val=$(sysctl kernel.keys.maxkeys)
    if [[ "${val##* }" -lt ${keyring_maxkeys} ]]; then
        sysctl -w kernel.keys.maxkeys=${keyring_maxkeys} >/dev/null 2>&1
    fi
}

# Adds user/group in charge of running all sysbox components.
add_sysbox_user() {

    if ! getent passwd | grep "^sysbox:" >/dev/null 2>&1; then
        useradd -r -s /bin/false sysbox
    fi
}

#
# There are two operational-modes in which Sysbox can function. Sysbox installer
# will automatically pick mode 1) if 'shiftfs' module is available AND docker is
# not operating in userns-remap mode. Otherwise, we will choose option 2).
#
# 1) uid-shifting mode: In this case no 'userns-remap' should be present in
#    dockerd's configuration.
# 2) non-uid-shifting mode: In this mode a 'userns-remap' entry will be added (if
#    not already present) along the 'sysbox' user previously created.
#
adjust_docker_config_userns() {
    local uid_shift_mode=true

    # Skip userns-remap config processing if docker is already operating in this
    # mode.
    if jq --exit-status 'has("userns-remap")' ${dockerCfgFile} &> /dev/null &&
        jq --exit-status '."userns-remap"' ${dockerCfgFile} | egrep -q -v "\"\"" &> /dev/null; then
        docker_restart_required=false
        return
    fi

    # If 'shiftfs' is not present, then check user's debconf response to our
    # config-automation question.
    if ! lsmod | grep "${shiftfs_module}" &> /dev/null ; then
        uid_shift_mode=false

        db_get sysbox/docker_userns_autoconfig
        if [ "$RET" = "false" ]; then
            docker_restart_required=false
            return
        fi
    fi

    # Consider adding a 'userns-remap' entry only if uid-shift-mode is turned
    # off.
    if [[ ${uid_shift_mode} = false ]]; then
        # If no 'userns-remap' key-entry is present, or if its associated value
        # is empty, proceed to create a key and set its value to 'sysbox' user.
        # Note that 'jq' does not provide 'in-place' editing capabilities (i.e.
        # it displays inconsistent behavior), hence the need for the auxiliar
        # 'tmp' file.
        if [[ $(jq 'has("userns-remap")' ${dockerCfgFile}) = false ]] ||
            [[ $(jq '."userns-remap"' ${dockerCfgFile}) = "\"\"" ]]; then

            jq --indent 4 '. + {"userns-remap": "sysbox"}' \
                ${dockerCfgFile} > tmp.json && mv tmp.json ${dockerCfgFile}

            docker_restart_required=true
        fi
    fi
}

#
# Add sysbox runtime to docker configuration.
#
adjust_docker_config_runtime() {

    # If no 'runtimes' key-entry is present, proceed to add one.
    if [[ $(jq 'has("runtimes")' ${dockerCfgFile}) = false ]]; then
        jq --indent 4 '. + {"runtimes": {"sysbox-runc": {"path": "/usr/local/sbin/sysbox-runc"}}}' \
            ${dockerCfgFile} > tmp.json && mv tmp.json ${dockerCfgFile}

        docker_sighup_required=true

    # If no 'sysbox-runc' runtime entry is present, proceed to add it.
    elif [[ $(jq '.runtimes | has("sysbox-runc")' ${dockerCfgFile}) = false ]]; then
        jq --indent 4 '.runtimes |= . + {"sysbox-runc": {"path": "/usr/local/sbin/sysbox-runc"}}' \
            ${dockerCfgFile} > tmp.json && mv tmp.json ${dockerCfgFile}

        docker_sighup_required=true
    fi
}

#
# Create/Modify dockerd configuration to meet Sysbox requirements.
#
adjust_docker_config() {

    # If no dockerd default config-file exist, or if there's no content on it,
    # create one with a bare json layout.
    if [[ ! -f ${dockerCfgFile} ]] || [[ ! -s ${dockerCfgFile} ]]; then
        mkdir -p ${dockerCfgDir}
        touch ${dockerCfgFile}
        echo -e "{\n}" > ${dockerCfgFile}
    fi

    adjust_docker_config_userns

    adjust_docker_config_runtime

    # Return here if docker is not installed. We can't do it earlier than this
    # as the user could potentially install docker after sysbox.
    if ! command -v docker >/dev/null 2>&1; then
        return
    fi

    # Restart docker if required.
    if [[ ${docker_restart_required} = true ]]; then

        # If existing containers are found then skip docker-restart to avoid any
        # service disruption.
        if ! docker ps -a | wc -l | egrep -q "1"; then
            echo -e "\nDocker service was not restarted to avoid affecting existing" \
                    "containers. Please remove them and restart Docker by doing:\n" \
                    "\t\"docker stop \$(docker ps -a -q) &&" \
                    "docker container prune -f &&" \
                    "sudo systemctl restart docker\"\n"
            return
        fi

        systemctl restart docker
        return
    fi

    # If non-disruptive changes have been made to docker config, then send it a
    # sighup to have its config file getting re-parsed (no need to cold-boot).
    if [[ ${docker_sighup_required} = true ]]; then
	    kill -SIGHUP $(pidof dockerd)
    fi
}

#
# Verify if kernel-headers are properly installed and alert user otherwise.
#
check_kernel_headers() {

    #if ! dpkg-query -W -f='${Status} ${Version}\n' linux-headers-$(uname -r) \
    if ! dpkg -s linux-headers-$(uname -r) | egrep -q "install ok installed"; then
        echo -e "\nThe linux kernel headers package was not found. This may be"\
                "expected by user applications running within Sysbox containers."\
                "Please install it with this command:\n"\
                "\t\"sudo apt-get install -y linux-headers-\$(uname -r)\"\n"
    fi
}

config_sysbox() {

    # Ensure sysbox-fs' default mountpoint is created in the file-system.
    create_sysboxfs_mountpoint

    # Allows user-namespaces creation for unprivileged users. This change will
    # persist through system reboots by relying on a sysctl.d config-file to be
    # generated as part of this package's installation process.
    enable_unprivileged_userns

    # Ensure kernel's inotify resources can meet Sysbox's scaling requirements.
    define_inotify_resources

    # Ensure kernel's keyring resources can meet Sysbox's scaling requirements.
    define_keyring_resources

    # Add 'sysbox' user to host a large pool of subordinate UIDs/GIDs to be
    # shared across all system-containers. This user must match the one defined
    # in the docker configuration file.
    add_sysbox_user

    # Adjust dockerd configuration.
    adjust_docker_config

    # Check for kernel-headers.
    check_kernel_headers
}


case "$1" in
    configure)
        # Adjust system's configuration to satisfy Sysbox requirements.
        config_sysbox

        # Avoid calling exit() here to allow debhelper tools to add their
        # auto-generated code further below.
        ;;

    abort-*)
        ;;

    *)
        ;;
esac

#DEBHELPER#
